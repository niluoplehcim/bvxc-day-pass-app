BVXC Payment App Overview

Live (current) URL: https://019b2621-4e77-3206-b803-421600641f45.share.connect.posit.cloud

This is a single-file R Shiny web app that sells day passes, season passes, Christmas passes, programs, special events, and donations. Users add items to a cart and pay using Square Online Checkout. The admin team manages prices, availability, blocked dates, events, and global limits inside the app; those settings persist in the database (Supabase/Postgres on the deployed app; optional SQLite for local dev).

Architecture and Data Flow
Components

Shiny (R): UI + server logic, validation, cart, admin controls, reporting.

Database

Supabase (Postgres) for deployed persistence (recommended).

SQLite fallback for local development only.

Square: creates a payment link (Square-hosted checkout page) and processes card payments.

Posit Connect Cloud: hosts and runs the Shiny app; pulls code from GitHub and deploys via manifest.json / renv.lock.

High-level flow

User selects items (Day Pass / Season / Programs / Events / Donation) and clicks Add to cart.

App stores items in an in-memory Shiny reactive cart (rv$cart).

On Cart → Pay now:

App writes a transaction row to the database with status = PENDING (or sandbox variants).

App calls Square to create a payment link using cart line items.

App redirects the browser to Square checkout.

After payment, Square redirects back to the app using a receipt token in the URL.

App looks up the transaction by receipt token and (when possible) confirms status by polling Square (order/payment lookup), then shows a receipt panel and QR code.

Database Schema and What Gets Stored
config table

Key/value store for all admin-controlled variables, including:

Prices (day passes, season passes, Christmas pass, programs)

Kids Ski Program age-category pricing (hard-coded categories; prices are admin-set)

Global limits (max total CAD, max total items)

Tab enable/disable flags

Early-bird cutoff date

transactions table

One row per checkout attempt:

created_at, buyer info, total_amount_cents, currency

cart_json containing the cart line items (used for reports)

Square IDs when applicable (square_checkout_id, square_order_id)

receipt_token used to find the transaction after redirect

status (PENDING, COMPLETED, FAILED, etc.)

special_events table

Admin-managed events:

name, date, price, capacity (currently informational unless you enforce it), enabled flag

blocked_dates table

Dates where Day Pass payments are disallowed (UI blocks and server enforces).

How Pricing Works
Hard-coded category lists (stable)

Kids Ski Program age categories are fixed:

4–10 yrs, 11–12 yrs, 13–14 yrs, 15–16 yrs, 17–18 yrs, 18+ yrs

These are stable labels in the UI and in cart descriptions.

Admin-controlled prices (dynamic)

All prices are pulled at runtime from config.
If a price is missing/blank, it becomes N/A and the app blocks adding that item to cart.

Limits and Validation

Global cart validation is applied at add-to-cart time and again at checkout:

Max transaction total CAD (limit_max_total_cad)

Max total number of items (limit_max_items_total)

Blocked dates are enforced when choosing day-pass dates.

User Guide
Public user (non-admin)

Open the app URL.

Go to a tab (Day Pass / Season Pass / Programs / Special Events / Donation).

Enter quantities, choose dates/options, click Add to cart.

Go to Cart:

Enter name (optional but recommended)

Enter email (required for receipt)

Click Pay now

Complete payment on Square’s checkout page.

You’ll be redirected back and see a payment status + QR code.

Admin

Open Admin tab.

Enter admin password and log in.

Admin capabilities:

Set prices (including Kids Ski age-category pricing)

Set early-bird cutoff

Enable/disable tabs

Set global limits

Create/update/delete special events

Add/remove blocked dates

Run reports:

Date range summary

Line-item aggregation

Download CSVs (transactions + expanded line-items)

Coder Guide
Repo contents and dependency management

app.R is the app (single-file architecture).

Dependencies are captured via renv.lock and deployed using manifest.json (generated by rsconnect::writeManifest()).

Environment variables (critical)

Square

SQUARE_ENV = sandbox or production

BVXC_SANDBOX_MODE = fake (no Square call) or square (real sandbox checkout)

SQUARE_ACCESS_TOKEN

SQUARE_LOCATION_ID

SQUARE_VERSION (API version header)

Database

BVXC_DB_URL = Postgres/Supabase connection string (deployed)

BVXC_ALLOW_SQLITE_FALLBACK = 1 only for local dev (should be 0 in production)

App

BVXC_ADMIN_PASSWORD

BVXC_RETURN_BASE_URL (used to build the post-checkout redirect URL containing ?receipt=)

Key internal concepts

rv$cart holds the live cart in memory (reactiveValues).

Checkout creates a transaction row with a receipt_token.

Redirect back uses receipt_token to reload and display payment state.

Reports parse cart_json back into line items for aggregation.

Known implementation choice

Payment confirmation uses redirect + polling (Square order/payment lookup).
For higher integrity, production should add Square webhooks (see below).

What’s Left to Enter Production

Here’s the real checklist—this is what matters.

1) Square production readiness

Switch SQUARE_ENV=production

Use production SQUARE_ACCESS_TOKEN + SQUARE_LOCATION_ID

Confirm checkout works end-to-end with real cards

Confirm your return URL (BVXC_RETURN_BASE_URL) is correct for production

2) Add Square webhooks (recommended)

Right now, status is confirmed via redirect/polling. That works, but it’s not ideal.
Production-grade approach:

Configure Square webhooks (payment/order events)

Verify webhook signatures

Update transactions.status based on webhook events
This removes reliance on the user returning to the app and makes reconciliation cleaner.

3) Capacity enforcement (if you want it real)

Events have capacity, but unless you explicitly implemented reservation counting and blocking, capacity is currently informational.
Production needs:

Count confirmed registrations per event

Reject adds/checkout if capacity would be exceeded

Decide whether “pending carts” reserve spots or not (and if yes, add expiry)

4) Admin hardening

Add logout

Consider rate limiting / lockouts (you already have a basic lockout pattern)

Consider multiple admin users and audit logs (optional but worth it)

5) Reporting / accounting consistency

Decide what “revenue” means:

Include only COMPLETED? (recommended)

Exclude sandbox and failed/canceled

Add a report filter UI to select statuses

6) Operational basics

Backups of Supabase DB

Monitoring (error logs, uptime)

Privacy policy and data retention statement (you’re storing names/emails)

Confirm TLS is handled (Connect Cloud handles HTTPS)

7) Domain and branding (optional)

If you want a nicer URL than the Connect Cloud share link:

Put it behind your own domain (reverse proxy or Connect configuration, depending on your plan/capabilities)

One-paragraph “mechanics summary” for developers

Shiny renders the UI and keeps a reactive cart in memory. Admin configuration is persisted in a config key/value table in Postgres (Supabase) so prices, limits, and tab availability are editable without code changes. On checkout, the app writes a transaction row containing serialized cart items (cart_json), calls Square to create an Online Checkout payment link, then redirects the browser to Square. After payment, Square redirects back with a receipt token; the app reloads the transaction and attempts to confirm status by polling Square order/payment endpoints, then displays a receipt panel and QR code. Special events and blocked dates are stored as first-class DB tables. Reports rehydrate cart_json to produce summary and CSV exports.

If you want, I can also generate a README.md you can paste directly into GitHub (with install/run/deploy steps and env var templates) based on this exact v5.8 behavior.
